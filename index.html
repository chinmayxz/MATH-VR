<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VR Math Trivia</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
        }
        #vrButton {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 15px 25px;
            background: linear-gradient(135deg, #ff00ff, #00ffff);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1.1em;
            cursor: pointer;
            box-shadow: 0 4px 20px rgba(255, 0, 255, 0.5);
            transition: all 0.3s;
            z-index: 1000;
            font-weight: bold;
        }
        #vrButton:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 25px rgba(255, 0, 255, 0.7);
        }
        #instructions {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 0.9em;
            z-index: 999;
        }
        .vr-mode #instructions {
            display: none;
        }
    </style>
</head>
<body>
    <button id="vrButton">ðŸ¥½ ENTER VR MODE</button>
    <div id="instructions">Drag to look around â€¢ Click VR button for 360Â° immersive view</div>

    <script>
        let scene, camera, renderer, vrButton;
        let score = 0;
        let currentQuestion = 0;
        let attempted = false;
        let currentCategory = '';
        let particleSystem;
        let isVRMode = false;
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let cameraRotation = { x: 0, y: 0 };
        
        // 3D UI elements
        let uiGroup, questionMesh, answerMeshes = [];
        let scoreMesh, progressMesh;

        const questions = {
            geometry: [
                {q: "What is the sum of angles in a triangle?", a: ["180Â°", "360Â°", "90Â°", "270Â°"], c: 0},
                {q: "How many sides does a hexagon have?", a: ["5", "6", "7", "8"], c: 1},
                {q: "What is the area of a circle with radius 5?", a: ["78.5", "31.4", "15.7", "157"], c: 0},
                {q: "What is the perimeter of a square with side 4?", a: ["8", "12", "16", "20"], c: 2},
                {q: "How many faces does a cube have?", a: ["4", "6", "8", "12"], c: 1},
                {q: "What is the volume of a cube with side 3?", a: ["9", "18", "27", "81"], c: 2},
                {q: "What is the sum of angles in a quadrilateral?", a: ["180Â°", "270Â°", "360Â°", "450Â°"], c: 2},
                {q: "What is the diagonal of a square with side 1?", a: ["1", "âˆš2", "2", "âˆš3"], c: 1},
                {q: "How many edges does a cylinder have?", a: ["0", "1", "2", "3"], c: 2},
                {q: "What is the area of a rectangle 5x3?", a: ["8", "15", "30", "25"], c: 1},
                {q: "What is the circumference of circle r=2?", a: ["6.28", "12.56", "3.14", "9.42"], c: 1},
                {q: "How many vertices in square pyramid?", a: ["4", "5", "6", "8"], c: 1},
                {q: "Area of triangle base=6 height=4?", a: ["10", "12", "24", "48"], c: 1},
                {q: "Triangle with all sides equal?", a: ["Isosceles", "Equilateral", "Scalene", "Right"], c: 1},
                {q: "Degrees in a straight angle?", a: ["90Â°", "180Â°", "270Â°", "360Â°"], c: 1}
            ],
            algebra: [
                {q: "Solve for x: 2x + 5 = 15", a: ["5", "10", "7.5", "20"], c: 0},
                {q: "What is xÂ² when x = 4?", a: ["8", "16", "12", "20"], c: 1},
                {q: "Simplify: 3x + 2x", a: ["5x", "6x", "5xÂ²", "xâµ"], c: 0},
                {q: "What is the value of 2Â³?", a: ["6", "8", "9", "12"], c: 1},
                {q: "Solve: x/3 = 6", a: ["2", "9", "18", "3"], c: 2},
                {q: "What is âˆš49?", a: ["6", "7", "8", "9"], c: 1},
                {q: "Simplify: (xÂ²)(xÂ³)", a: ["xâµ", "xâ¶", "xâ¹", "2xâµ"], c: 0},
                {q: "Solve for x: 3x - 7 = 14", a: ["5", "6", "7", "8"], c: 2},
                {q: "What is 5Â² - 3Â²?", a: ["4", "8", "16", "32"], c: 2},
                {q: "Factor: xÂ² - 9", a: ["(x-3)(x-3)", "(x+3)(x+3)", "(x-3)(x+3)", "x(x-9)"], c: 2},
                {q: "Solve: 4x = 28", a: ["4", "7", "24", "32"], c: 1},
                {q: "What is (-2)Â³?", a: ["6", "-6", "8", "-8"], c: 3},
                {q: "Simplify: 2(x + 3)", a: ["2x + 3", "2x + 6", "x + 6", "2x + 5"], c: 1},
                {q: "Slope of y = 3x + 2?", a: ["2", "3", "5", "x"], c: 1},
                {q: "Solve: x + 8 = 15", a: ["7", "8", "23", "15"], c: 0}
            ],
            calculus: [
                {q: "What is the derivative of xÂ²?", a: ["x", "2x", "xÂ²", "2"], c: 1},
                {q: "What is âˆ«x dx?", a: ["x", "xÂ²", "xÂ²/2 + C", "2x"], c: 2},
                {q: "Derivative of a constant?", a: ["1", "0", "x", "Undefined"], c: 1},
                {q: "Derivative of 3x?", a: ["3", "3x", "x", "0"], c: 0},
                {q: "What is lim(xâ†’0) sin(x)/x?", a: ["0", "1", "âˆž", "Undefined"], c: 1},
                {q: "Derivative of eË£?", a: ["eË£", "xeË£â»Â¹", "ln(x)", "1/x"], c: 0},
                {q: "What is âˆ«1 dx?", a: ["0", "1", "x + C", "x"], c: 2},
                {q: "Derivative of ln(x)?", a: ["1", "1/x", "x", "ln(x)"], c: 1},
                {q: "Derivative of sin(x)?", a: ["cos(x)", "-cos(x)", "sin(x)", "-sin(x)"], c: 0},
                {q: "What is âˆ«2x dx?", a: ["2x", "xÂ²", "xÂ² + C", "2xÂ² + C"], c: 2},
                {q: "Power rule for xâ¿?", a: ["nxâ¿", "nxâ¿â»Â¹", "xâ¿â»Â¹", "xâ¿/n"], c: 1},
                {q: "Derivative of xÂ³?", a: ["3x", "3xÂ²", "xÂ²", "3xÂ³"], c: 1},
                {q: "Derivative of cos(x)?", a: ["sin(x)", "-sin(x)", "cos(x)", "-cos(x)"], c: 1},
                {q: "What is âˆ«f'(x)dx?", a: ["f'(x)", "f(x) + C", "0", "f''(x)"], c: 1},
                {q: "Derivative of 5xÂ²?", a: ["5x", "10x", "5xÂ²", "10"], c: 1}
            ]
        };

        let gameState = 'start'; // start, category, game, results

        function createTextTexture(text, options = {}) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = options.width || 1024;
            canvas.height = options.height || 256;
            
            ctx.fillStyle = options.bgColor || 'rgba(0, 20, 40, 0.95)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            if (options.border) {
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
                ctx.lineWidth = 8;
                ctx.strokeRect(4, 4, canvas.width - 8, canvas.height - 8);
            }
            
            ctx.fillStyle = options.color || '#ffffff';
            ctx.font = options.font || 'bold 60px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const lines = text.split('\n');
            const lineHeight = canvas.height / (lines.length + 1);
            lines.forEach((line, i) => {
                ctx.fillText(line, canvas.width / 2, lineHeight * (i + 1));
            });
            
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            scene.fog = new THREE.Fog(0x87ceeb, 50, 200);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 30);
            camera.lookAt(0, 5, 0);

            renderer = new THREE.WebGLRenderer({antialias: true});
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);

            // VR Button
            vrButton = document.getElementById('vrButton');
            vrButton.addEventListener('click', toggleVRMode);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 50, 50);
            scene.add(directionalLight);

            // Water pool
            const poolGeometry = new THREE.CylinderGeometry(25, 25, 1, 32);
            const poolMaterial = new THREE.MeshPhongMaterial({
                color: 0x1e90ff,
                transparent: true,
                opacity: 0.7,
                shininess: 100
            });
            const pool = new THREE.Mesh(poolGeometry, poolMaterial);
            pool.position.y = 0;
            scene.add(pool);

            // Cliffs
            for (let i = 0; i < 3; i++) {
                const cliffGeometry = new THREE.BoxGeometry(15, 40, 15);
                const cliffMaterial = new THREE.MeshPhongMaterial({color: 0x808080});
                const cliff = new THREE.Mesh(cliffGeometry, cliffMaterial);
                cliff.position.set(
                    Math.cos(i * Math.PI * 2 / 3) * 30,
                    20,
                    Math.sin(i * Math.PI * 2 / 3) * 30
                );
                scene.add(cliff);
            }

            // Waterfall particles
            const particleCount = 1000;
            const particles = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * 60;
                positions[i + 1] = Math.random() * 50 + 10;
                positions[i + 2] = (Math.random() - 0.5) * 60;
            }
            
            particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.3,
                transparent: true,
                opacity: 0.8
            });
            
            particleSystem = new THREE.Points(particles, particleMaterial);
            scene.add(particleSystem);

            // Trees
            for (let i = 0; i < 15; i++) {
                const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.7, 8, 8);
                const trunkMaterial = new THREE.MeshPhongMaterial({color: 0x8b4513});
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                
                const leavesGeometry = new THREE.SphereGeometry(3, 8, 8);
                const leavesMaterial = new THREE.MeshPhongMaterial({color: 0x228b22});
                const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                leaves.position.y = 6;
                
                trunk.add(leaves);
                
                const angle = (i / 15) * Math.PI * 2;
                const radius = 35 + Math.random() * 10;
                trunk.position.set(
                    Math.cos(angle) * radius,
                    4,
                    Math.sin(angle) * radius
                );
                
                scene.add(trunk);
            }

            // Create UI group
            uiGroup = new THREE.Group();
            scene.add(uiGroup);

            // Mouse controls
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('click', onCanvasClick);

            // Touch controls
            renderer.domElement.addEventListener('touchstart', onTouchStart);
            renderer.domElement.addEventListener('touchmove', onTouchMove);
            renderer.domElement.addEventListener('touchend', onTouchEnd);

            showStartScreen();
            renderer.setAnimationLoop(animate);
        }

        function toggleVRMode() {
            isVRMode = !isVRMode;
            if (isVRMode) {
                if (renderer.domElement.requestFullscreen) {
                    renderer.domElement.requestFullscreen();
                }
                vrButton.textContent = 'ðŸ¥½ EXIT VR MODE';
                document.body.classList.add('vr-mode');
                camera.fov = 90;
            } else {
                if (document.exitFullscreen && document.fullscreenElement) {
                    document.exitFullscreen();
                }
                vrButton.textContent = 'ðŸ¥½ ENTER VR MODE';
                document.body.classList.remove('vr-mode');
                camera.fov = 75;
            }
            camera.updateProjectionMatrix();
        }

        function onMouseDown(event) {
            isDragging = true;
            previousMousePosition = { x: event.clientX, y: event.clientY };
        }

        function onMouseMove(event) {
            if (isDragging) {
                const deltaX = event.clientX - previousMousePosition.x;
                const deltaY = event.clientY - previousMousePosition.y;
                
                cameraRotation.y += deltaX * 0.005;
                cameraRotation.x += deltaY * 0.005;
                cameraRotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraRotation.x));
                
                previousMousePosition = { x: event.clientX, y: event.clientY };
            }
        }

        function onMouseUp() {
            isDragging = false;
        }

        let touchStartX = 0, touchStartY = 0;
        function onTouchStart(event) {
            if (event.touches.length === 1) {
                touchStartX = event.touches[0].clientX;
                touchStartY = event.touches[0].clientY;
            }
        }

        function onTouchMove(event) {
            if (event.touches.length === 1) {
                const deltaX = event.touches[0].clientX - touchStartX;
                const deltaY = event.touches[0].clientY - touchStartY;
                
                cameraRotation.y += deltaX * 0.005;
                cameraRotation.x += deltaY * 0.005;
                cameraRotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraRotation.x));
                
                touchStartX = event.touches[0].clientX;
                touchStartY = event.touches[0].clientY;
            }
        }

        function onTouchEnd() {
            // Touch ended
        }

        function onCanvasClick(event) {
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(uiGroup.children, true);
            if (intersects.length > 0) {
                const object = intersects[0].object;
                if (object.userData.onClick) {
                    object.userData.onClick();
                }
            }
        }

        function clearUI() {
            while (uiGroup.children.length > 0) {
                uiGroup.remove(uiGroup.children[0]);
            }
        }

        function showStartScreen() {
            clearUI();
            gameState = 'start';
            
            const titleTexture = createTextTexture('VR Math Trivia\nðŸŒŠ', {
                width: 2048,
                height: 512,
                color: '#00ffff',
                font: 'bold 120px Arial',
                border: true
            });
            const titleMaterial = new THREE.MeshBasicMaterial({ map: titleTexture, transparent: true });
            const titleMesh = new THREE.Mesh(new THREE.PlaneGeometry(20, 5), titleMaterial);
            titleMesh.position.set(0, 15, 0);
            uiGroup.add(titleMesh);

            const startTexture = createTextTexture('START GAME', {
                width: 1024,
                height: 256,
                color: '#ffffff',
                font: 'bold 80px Arial',
                bgColor: 'rgba(0, 102, 204, 0.9)',
                border: true
            });
            const startMaterial = new THREE.MeshBasicMaterial({ map: startTexture, transparent: true });
            const startButton = new THREE.Mesh(new THREE.PlaneGeometry(12, 3), startMaterial);
            startButton.position.set(0, 8, 0);
            startButton.userData.onClick = showCategories;
            uiGroup.add(startButton);
        }

        function showCategories() {
            clearUI();
            gameState = 'category';
            
            const titleTexture = createTextTexture('Choose Category', {
                width: 1024,
                height: 256,
                color: '#00ddff',
                font: 'bold 80px Arial',
                border: true
            });
            const titleMaterial = new THREE.MeshBasicMaterial({ map: titleTexture, transparent: true });
            const titleMesh = new THREE.Mesh(new THREE.PlaneGeometry(15, 3), titleMaterial);
            titleMesh.position.set(0, 18, 0);
            uiGroup.add(titleMesh);

            const categories = [
                { name: 'ðŸ“ Geometry', key: 'geometry', y: 13 },
                { name: 'ðŸ”¢ Algebra', key: 'algebra', y: 8 },
                { name: 'ðŸ“Š Calculus', key: 'calculus', y: 3 }
            ];

            categories.forEach(cat => {
                const texture = createTextTexture(cat.name, {
                    width: 1024,
                    height: 256,
                    color: '#ffffff',
                    font: 'bold 70px Arial',
                    bgColor: 'rgba(26, 80, 128, 0.9)',
                    border: true
                });
                const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
                const button = new THREE.Mesh(new THREE.PlaneGeometry(14, 3.5), material);
                button.position.set(0, cat.y, 0);
                button.userData.onClick = () => startGame(cat.key);
                uiGroup.add(button);
            });
        }

        function startGame(category) {
            currentCategory = category;
            score = 0;
            currentQuestion = 0;
            gameState = 'game';
            loadQuestion();
        }

        function loadQuestion() {
            if (currentQuestion >= 10) {
                showResults();
                return;
            }

            clearUI();
            attempted = false;
            
            const categoryQuestions = questions[currentCategory];
            const randomQ = categoryQuestions[Math.floor(Math.random() * categoryQuestions.length)];
            
            // Score
            const scoreTexture = createTextTexture(`Score: ${score}`, {
                width: 512,
                height: 128,
                color: '#ffff00',
                font: 'bold 50px Arial',
                bgColor: 'rgba(0, 0, 0, 0.8)'
            });
            scoreMesh = new THREE.Mesh(
                new THREE.PlaneGeometry(8, 2),
                new THREE.MeshBasicMaterial({ map: scoreTexture, transparent: true })
            );
            scoreMesh.position.set(-10, 18, 0);
            uiGroup.add(scoreMesh);

            // Progress
            const progressTexture = createTextTexture(`Question ${currentQuestion + 1}/10`, {
                width: 512,
                height: 128,
                color: '#aaddff',
                font: 'bold 50px Arial',
                bgColor: 'rgba(0, 0, 0, 0.8)'
            });
            progressMesh = new THREE.Mesh(
                new THREE.PlaneGeometry(8, 2),
                new THREE.MeshBasicMaterial({ map: progressTexture, transparent: true })
            );
            progressMesh.position.set(10, 18, 0);
            uiGroup.add(progressMesh);

            // Question
            const questionTexture = createTextTexture(randomQ.q, {
                width: 2048,
                height: 512,
                color: '#ffffff',
                font: 'bold 60px Arial',
                border: true
            });
            questionMesh = new THREE.Mesh(
                new THREE.PlaneGeometry(20, 5),
                new THREE.MeshBasicMaterial({ map: questionTexture, transparent: true })
            );
            questionMesh.position.set(0, 12, 0);
            uiGroup.add(questionMesh);

            // Answers
            answerMeshes = [];
            randomQ.a.forEach((answer, index) => {
                const texture = createTextTexture(answer, {
                    width: 1024,
                    height: 256,
                    color: '#ffffff',
                    font: 'bold 60px Arial',
                    bgColor: 'rgba(26, 80, 144, 0.9)',
                    border: true
                });
                const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
                const button = new THREE.Mesh(new THREE.PlaneGeometry(18, 3), material);
                button.position.set(0, 6 - index * 3.5, 0);
                button.userData.index = index;
                button.userData.correct = randomQ.c;
                button.userData.onClick = () => checkAnswer(index, randomQ.c, button);
                uiGroup.add(button);
                answerMeshes.push(button);
            });
        }

        function checkAnswer(selected, correct, button) {
            if (selected === correct) {
                const correctTexture = createTextTexture(button.material.map.image.textContent || 'CORRECT!', {
                    width: 1024,
                    height: 256,
                    color: '#ffffff',
                    font: 'bold 60px Arial',
                    bgColor: 'rgba(0, 170, 0, 0.9)',
                    border: true
                });
                button.material.map = correctTexture;
                button.material.needsUpdate = true;
                
                if (!attempted) {
                    score += 10;
                    const scoreTexture = createTextTexture(`Score: ${score}`, {
                        width: 512,
                        height: 128,
                        color: '#ffff00',
                        font: 'bold 50px Arial',
                        bgColor: 'rgba(0, 0, 0, 0.8)'
                    });
                    scoreMesh.material.map = scoreTexture;
                    scoreMesh.material.needsUpdate = true;
                }
                
                setTimeout(() => {
                    currentQuestion++;
                    loadQuestion();
                }, 1000);
            } else {
                const incorrectTexture = createTextTexture('TRY AGAIN', {
                    width: 1024,
                    height: 256,
                    color: '#ffffff',
                    font: 'bold 60px Arial',
                    bgColor: 'rgba(170, 0, 0, 0.9)',
                    border: true
                });
                button.material.map = incorrectTexture;
                button.material.needsUpdate = true;
                attempted = true;
                
                setTimeout(() => {
                    loadQuestion();
                }, 800);
            }
        }

        function showResults() {
            clearUI();
            gameState = 'results';
            
            const titleTexture = createTextTexture('Round Complete!\nðŸŽ‰', {
                width: 2048,
                height: 512,
                color: '#00ffff',
                font: 'bold 100px Arial',
                border: true
            });
            const titleMesh = new THREE.Mesh(
                new THREE.PlaneGeometry(20, 5),
                new THREE.MeshBasicMaterial({ map: titleTexture, transparent: true })
            );
            titleMesh.position.set(0, 16, 0);
            uiGroup.add(titleMesh);

            const scoreTexture = createTextTexture(`Final Score: ${score}/100`, {
                width: 1024,
                height: 256,
                color: '#ffff00',
                font: 'bold 70px Arial',
                border: true
            });
            const scoreMesh = new THREE.Mesh(
                new THREE.PlaneGeometry(15, 3),
                new THREE.MeshBasicMaterial({ map: scoreTexture, transparent: true })
            );
            scoreMesh.position.set(0, 10, 0);
            uiGroup.add(scoreMesh);

            const playAgainTexture = createTextTexture('PLAY AGAIN', {
                width: 1024,
                height: 256,
                color: '#ffffff',
                font: 'bold 70px Arial',
                bgColor: 'rgba(0, 102, 204, 0.9)',
                border: true
            });
            const playAgainButton = new THREE.Mesh(
                new THREE.PlaneGeometry(13, 3),
                new THREE.MeshBasicMaterial({ map: playAgainTexture, transparent: true })
            );
            playAgainButton.position.set(0, 5, 0);
            playAgainButton.userData.onClick = showCategories;
            uiGroup.add(playAgainButton);

            const mainMenuTexture = createTextTexture('MAIN MENU', {
                width: 1024,
                height: 256,
                color: '#ffffff',
                font: 'bold 70px Arial',
                bgColor: 'rgba(80, 80, 80, 0.9)',
                border: true
            });
            const mainMenuButton = new THREE.Mesh(
                new THREE.PlaneGeometry(13, 3),
                new THREE.MeshBasicMaterial({ map: mainMenuTexture, transparent: true })
            );
            mainMenuButton.position.set(0, 0, 0);
            mainMenuButton.userData.onClick = showStartScreen;
            uiGroup.add(mainMenuButton);
        }

        function animate() {
            // Animate waterfall particles
            if (particleSystem) {
                const positions = particleSystem.geometry.attributes.position.array;
                for (let i = 1; i < positions.length; i += 3) {
                    positions[i] -= 0.3;
                    if (positions[i] < 0) {
                        positions[i] = 60;
                    }
                }
                particleSystem.geometry.attributes.position.needsUpdate = true;
            }
            
            // Update camera rotation based on user input
            camera.rotation.order = 'YXZ';
            camera.rotation.y = cameraRotation.y;
            camera.rotation.x = cameraRotation.x;
            
            // Keep UI in front of camera
            uiGroup.position.copy(camera.position);
            uiGroup.position.x += Math.sin(camera.rotation.y) * 25;
            uiGroup.position.z += Math.cos(camera.rotation.y) * 25;
            uiGroup.rotation.y = camera.rotation.y;
            
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        initScene();
